"""
RRT* Path Planner with Dubins Curves
Inputs: CSV file with environment obstacles
Outputs: CSV file with planned path (x, y, yaw)
"""

import math
import numpy as np
import csv
from scipy.spatial.transform import Rotation as Rot
from shapely.geometry import Point, LineString, Polygon
from tqdm import tqdm


# ==================== Dubins Path Implementation ====================

class PATH:
    def __init__(self, L, mode, x, y, yaw):
        self.L = L
        self.mode = mode
        self.x = x
        self.y = y
        self.yaw = yaw


def pi_2_pi(theta):
    while theta > math.pi:
        theta -= 2.0 * math.pi
    while theta < -math.pi:
        theta += 2.0 * math.pi
    return theta


def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)


def LSL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)
    
    if p_lsl < 0:
        return None, None, None, ["L", "S", "L"]
    else:
        p_lsl = math.sqrt(p_lsl)
    
    denominate = dist + sin_a - sin_b
    t_lsl = mod2pi(-alpha + math.atan2(cos_b - cos_a, denominate))
    q_lsl = mod2pi(beta - math.atan2(cos_b - cos_a, denominate))
    
    return t_lsl, p_lsl, q_lsl, ["L", "S", "L"]


def RSR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)
    
    if p_rsr < 0:
        return None, None, None, ["R", "S", "R"]
    else:
        p_rsr = math.sqrt(p_rsr)
    
    denominate = dist - sin_a + sin_b
    t_rsr = mod2pi(alpha - math.atan2(cos_a - cos_b, denominate))
    q_rsr = mod2pi(-beta + math.atan2(cos_a - cos_b, denominate))
    
    return t_rsr, p_rsr, q_rsr, ["R", "S", "R"]


def LSR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)
    
    if p_lsr < 0:
        return None, None, None, ["L", "S", "R"]
    else:
        p_lsr = math.sqrt(p_lsr)
    
    rec = math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr)
    t_lsr = mod2pi(-alpha + rec)
    q_lsr = mod2pi(-mod2pi(beta) + rec)
    
    return t_lsr, p_lsr, q_lsr, ["L", "S", "R"]


def RSL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)
    
    if p_rsl < 0:
        return None, None, None, ["R", "S", "L"]
    else:
        p_rsl = math.sqrt(p_rsl)
    
    rec = math.atan2(cos_a + cos_b, dist - sin_a - sin_b) - math.atan2(2.0, p_rsl)
    t_rsl = mod2pi(alpha - rec)
    q_rsl = mod2pi(beta - rec)
    
    return t_rsl, p_rsl, q_rsl, ["R", "S", "L"]


def RLR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    rec = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0
    
    if abs(rec) > 1.0:
        return None, None, None, ["R", "L", "R"]
    
    p_rlr = mod2pi(2 * math.pi - math.acos(rec))
    t_rlr = mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + mod2pi(p_rlr / 2.0))
    q_rlr = mod2pi(alpha - beta - t_rlr + mod2pi(p_rlr))
    
    return t_rlr, p_rlr, q_rlr, ["R", "L", "R"]


def LRL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    rec = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_b - sin_a)) / 8.0
    
    if abs(rec) > 1.0:
        return None, None, None, ["L", "R", "L"]
    
    p_lrl = mod2pi(2 * math.pi - math.acos(rec))
    t_lrl = mod2pi(-alpha - math.atan2(cos_a - cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)
    q_lrl = mod2pi(mod2pi(beta) - alpha - t_lrl + mod2pi(p_lrl))
    
    return t_lrl, p_lrl, q_lrl, ["L", "R", "L"]


def interpolate(ind, l, m, maxc, ox, oy, oyaw, px, py, pyaw, directions):
    if m == "S":
        px[ind] = ox + l / maxc * math.cos(oyaw)
        py[ind] = oy + l / maxc * math.sin(oyaw)
        pyaw[ind] = oyaw
    else:
        ldx = math.sin(l) / maxc
        if m == "L":
            ldy = (1.0 - math.cos(l)) / maxc
        elif m == "R":
            ldy = (1.0 - math.cos(l)) / (-maxc)
        
        gdx = math.cos(-oyaw) * ldx + math.sin(-oyaw) * ldy
        gdy = -math.sin(-oyaw) * ldx + math.cos(-oyaw) * ldy
        px[ind] = ox + gdx
        py[ind] = oy + gdy
    
    if m == "L":
        pyaw[ind] = oyaw + l
    elif m == "R":
        pyaw[ind] = oyaw - l
    
    if l > 0.0:
        directions[ind] = 1
    else:
        directions[ind] = -1
    
    return px, py, pyaw, directions


def generate_local_course(L, lengths, mode, maxc, step):
    point_num = int(L / step) + len(lengths) + 3
    
    px = [0.0 for _ in range(point_num)]
    py = [0.0 for _ in range(point_num)]
    pyaw = [0.0 for _ in range(point_num)]
    directions = [0 for _ in range(point_num)]
    ind = 1
    
    if lengths[0] > 0.0:
        directions[0] = 1
    else:
        directions[0] = -1
    
    if lengths[0] > 0.0:
        d = step
    else:
        d = -step
    
    ll = 0.0
    
    for m, l, i in zip(mode, lengths, range(len(mode))):
        if l > 0.0:
            d = step
        else:
            d = -step
        
        ox, oy, oyaw = px[ind], py[ind], pyaw[ind]
        
        ind -= 1
        if i >= 1 and (lengths[i - 1] * lengths[i]) > 0:
            pd = -d - ll
        else:
            pd = d - ll
        
        while abs(pd) <= abs(l):
            ind += 1
            px, py, pyaw, directions = interpolate(ind, pd, m, maxc, ox, oy, oyaw, px, py, pyaw, directions)
            pd += d
        
        ll = l - pd - d
        
        ind += 1
        px, py, pyaw, directions = interpolate(ind, l, m, maxc, ox, oy, oyaw, px, py, pyaw, directions)
    
    if len(px) <= 1:
        return [], [], [], []
    
    while len(px) >= 1 and px[-1] == 0.0:
        px.pop()
        py.pop()
        pyaw.pop()
        directions.pop()
    
    return px, py, pyaw, directions


def planning_from_origin(gx, gy, gyaw, curv, step):
    D = math.hypot(gx, gy)
    d = D * curv
    
    theta = mod2pi(math.atan2(gy, gx))
    alpha = mod2pi(-theta)
    beta = mod2pi(gyaw - theta)
    
    planners = [LSL, RSR, LSR, RSL, RLR, LRL]
    
    path_list = []
    for planner in planners:
        t, p, q, mode = planner(alpha, beta, d)
        
        if t is None:
            continue
        
        cost = (abs(t) + abs(p) + abs(q))
        lengths = [t, p, q]
        x_list, y_list, yaw_list, directions = generate_local_course(sum(lengths), lengths, mode, curv, step)
        path_list.append([x_list, y_list, yaw_list, mode, cost])
    
    return path_list


def calc_dubins_path(sx, sy, syaw, gx, gy, gyaw, curv, step=0.1):
    goal_x = gx - sx
    goal_y = gy - sy
    
    l_rot = Rot.from_euler('z', syaw).as_matrix()[0:2, 0:2]
    le_xy = np.stack([goal_x, goal_y]).T @ l_rot
    le_yaw = gyaw - syaw
    
    possible_paths = []
    path_list = planning_from_origin(le_xy[0], le_xy[1], le_yaw, curv, step)
    for path in path_list:
        lp_x, lp_y, lp_yaw, mode, lengths = path
        rot = Rot.from_euler('z', -syaw).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([lp_x, lp_y]).T @ rot
        x_list = converted_xy[:, 0] + sx
        y_list = converted_xy[:, 1] + sy
        yaw_list = [pi_2_pi(i_yaw + syaw) for i_yaw in lp_yaw]
        possible_paths.append(PATH(lengths, mode, x_list, y_list, yaw_list))
    return possible_paths


def plan_dubins_path(sx, sy, syaw, gx, gy, gyaw, maxc, step=0.2):
    paths = []
    for curve_rate in maxc:
        paths += calc_dubins_path(sx, sy, syaw, gx, gy, gyaw, curve_rate, step)
    if not paths:
        return None
    
    linestring_list = []
    for path in paths:
        x, y = np.array(path.x), np.array(path.y)
        coord = np.vstack((x, y)).T
        linestring_list.append(LineString(coord))
    return sorted(linestring_list, key=lambda x: x.length)


# ==================== RRT* Implementation ====================

class TreeNode:
    def __init__(self, point, yaw):
        self.point = point
        self.yaw = yaw
        self.cost = 0
        self.parent = None
        self.path_to_parent = None
        self.children = []


class Environment:
    def __init__(self, width, height, obstacles, start, goal, max_curvature):
        self.width = width
        self.height = height
        self.obstacles = obstacles
        self.start = start  # (Point, yaw)
        self.goal = goal    # (Point, yaw)
        self.max_curvature = max_curvature
        self.path = None
    
    def collision_free(self, geometry):
        for obstacle in self.obstacles:
            if geometry.intersects(obstacle):
                return False
        return True


def rand_coords(width, height):
    x = np.random.randint(0, width * 100, 1) / 100
    y = np.random.randint(0, height * 100, 1) / 100
    return Point(x, y)


def create_connector(node1, node2, env):
    maxc = env.max_curvature
    sx, sy, syaw = node1.point.x, node1.point.y, round(np.radians(round(node1.yaw, 2)), 2)
    gx, gy, gyaw = node2.point.x, node2.point.y, round(np.radians(round(node2.yaw, 2)), 2)
    
    if gx != sx and gy != sy:
        connect_line_list = plan_dubins_path(sx, sy, syaw, gx, gy, gyaw, maxc)
        if connect_line_list is not None:
            for connect_line in connect_line_list:
                if env.collision_free(connect_line):
                    return connect_line
    return None


def find_closest_node(env, start_node, new_node, min_length=float('inf')):
    nearest_node, shortest_path = None, None
    
    if start_node.children:
        for child in start_node.children:
            temp_node, temp_path, temp_length = find_closest_node(env, child, new_node, min_length=min_length)
            if temp_node is None:
                return nearest_node, shortest_path, min_length
            if temp_length < min_length:
                nearest_node, shortest_path, min_length = temp_node, temp_path, temp_length
    
    connect_line = create_connector(start_node, new_node, env)
    if connect_line is None:
        return nearest_node, shortest_path, min_length
    
    length = connect_line.length
    
    if length < min_length:
        nearest_node = start_node
        shortest_path = connect_line
        min_length = length
    
    return nearest_node, shortest_path, min_length


def find_nearby_nodes(start_node, goal_node, tol, nearby_nodes=[]):
    if start_node.children:
        for child in start_node.children:
            if child.point.distance(goal_node.point) < tol:
                nearby_nodes.append(child)
            find_nearby_nodes(child, goal_node, tol, nearby_nodes)
    return nearby_nodes


def update_children_cost(start_node, cost_difference):
    if start_node.children:
        for child in start_node.children:
            child.cost = child.cost - cost_difference
            update_children_cost(child, cost_difference)


def extract_path(final_node, path=[]):
    if final_node.parent is not None:
        path.append(final_node.path_to_parent)
        extract_path(final_node.parent, path)
    return path


def rrt_star_dubins(env, n_iter=1000, step_size=float('inf'), dist_tolerance=1):
    start_node = TreeNode(env.start[0], env.start[1])
    goal_node = TreeNode(env.goal[0], env.goal[1])
    
    for n in tqdm(range(n_iter), desc="RRT* Progress"):
        if n == 1:
            sampled_node = goal_node
        elif n == n_iter - 1:
            sampled_node = goal_node
        else:
            sampled_node = TreeNode(rand_coords(env.width, env.height), np.deg2rad(np.random.randint(0, 360, 1))[0])
            
            if not sampled_node.point.equals(goal_node.point) and np.random.random_sample() < 0.1:
                angle_to_goal = (np.degrees(np.arctan2((goal_node.point.y - sampled_node.point.y), 
                                                       (goal_node.point.x - sampled_node.point.x))) + 360) % 360
                sampled_node.yaw = np.deg2rad(angle_to_goal)
        
        if not env.collision_free(sampled_node.point):
            continue
        
        parent_node, path_to_parent, _ = find_closest_node(env, start_node, sampled_node)
        
        if parent_node is not None and not parent_node.point.equals(sampled_node.point):
            if path_to_parent.length > step_size:
                new_node_inradius = TreeNode(path_to_parent.interpolate(step_size), parent_node.yaw)
                sampled_node = new_node_inradius
            
            sampled_node.cost = parent_node.cost + path_to_parent.length
            
            radius = 20
            nodes_near_sample = find_nearby_nodes(start_node, sampled_node, radius, nearby_nodes=[])
            
            if nodes_near_sample:
                min_cost = sampled_node.cost
                
                for node in nodes_near_sample:
                    cost_estimate = sampled_node.point.distance(node.point) + min(abs(sampled_node.yaw - node.yaw), 
                                                                                   2 * math.pi - abs(sampled_node.yaw - node.yaw))
                    cost_via_node = node.cost + cost_estimate
                    
                    if cost_via_node < min_cost:
                        parent_node, min_cost = node, cost_via_node
            
            path_to_parent = create_connector(parent_node, sampled_node, env)
            if path_to_parent is None:
                continue
            
            sampled_node.cost = parent_node.cost + path_to_parent.length
            parent_node.children.append(sampled_node)
            sampled_node.parent = parent_node
            sampled_node.path_to_parent = path_to_parent
            
            if nodes_near_sample:
                for node in nodes_near_sample:
                    cost_estimate = sampled_node.point.distance(node.point) + min(abs(sampled_node.yaw - node.yaw), 
                                                                                   2 * math.pi - abs(sampled_node.yaw - node.yaw))
                    cost_via_sampled_node = sampled_node.cost + cost_estimate
                    
                    if cost_via_sampled_node < node.cost:
                        path_to_node = create_connector(sampled_node, node, env)
                        if path_to_node is None:
                            continue
                        
                        node_updated_cost = sampled_node.cost + path_to_node.length
                        if node_updated_cost < node.cost:
                            node.parent.children.remove(node)
                            node.parent = sampled_node
                            node.path_to_parent = path_to_node
                            sampled_node.children.append(node)
                            
                            node_cost_difference = node.cost - node_updated_cost
                            update_children_cost(node, node_cost_difference)
    
    nodes_near_goal = find_nearby_nodes(start_node, goal_node, dist_tolerance, nearby_nodes=[])
    
    if nodes_near_goal:
        node_min_cost = min(nodes_near_goal, key=lambda x: (x.cost) * 
                           (goal_node.point.distance(x.point) + min(abs(goal_node.yaw - x.yaw), 
                                                                     2 * math.pi - abs(goal_node.yaw - x.yaw))))
        path = extract_path(node_min_cost)
        print(f"\nRRT* completed successfully in {n_iter} iterations")
        return path[::-1]  # Reverse to get path from start to goal
    else:
        raise Exception("RRT* could not find a path. Try increasing iterations or adjusting parameters.")


# ==================== CSV I/O Functions ====================

def load_environment_from_csv(filename):
    """
    Load environment from CSV file.
    Expected format:
    - First row: width,height,max_curvature
    - Second row: start_x,start_y,start_yaw_deg
    - Third row: goal_x,goal_y,goal_yaw_deg
    - Following rows: obstacle vertices as x1,y1,x2,y2,x3,y3,...
    """
    with open(filename, 'r') as f:
        reader = csv.reader(f)
        
        # Read environment dimensions and parameters
        params = next(reader)
        width, height, max_curv = float(params[0]), float(params[1]), [float(params[2])]
        
        # Read start position
        start_data = next(reader)
        start = (Point(float(start_data[0]), float(start_data[1])), float(start_data[2]))
        
        # Read goal position
        goal_data = next(reader)
        goal = (Point(float(goal_data[0]), float(goal_data[1])), float(goal_data[2]))
        
        # Read obstacles
        obstacles = []
        for row in reader:
            if len(row) >= 6:  # At least 3 points (x,y pairs) to make a polygon
                coords = [(float(row[i]), float(row[i+1])) for i in range(0, len(row), 2)]
                obstacles.append(Polygon(coords))
        
    return Environment(width, height, obstacles, start, goal, max_curv)


def save_path_to_csv(path, filename):
    """
    Save path to CSV file with x, y, yaw columns.
    """
    with open(filename, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['x', 'y', 'yaw_deg'])
        
        for segment in path:
            coords = list(segment.coords)
            for coord in coords:
                x, y = coord
                # Extract yaw from segment (simplified - using direction between points)
                idx = coords.index(coord)
                if idx < len(coords) - 1:
                    dx = coords[idx + 1][0] - x
                    dy = coords[idx + 1][1] - y
                    yaw_rad = math.atan2(dy, dx)
                    yaw_deg = math.degrees(yaw_rad)
                else:
                    yaw_deg = math.degrees(yaw_rad) if idx > 0 else 0
                
                writer.writerow([x, y, yaw_deg])
    
    print(f"Path saved to {filename}")


# ==================== Main Function ====================

if __name__ == "__main__":
    # Example usage
    print("RRT* with Dubins Path Planner")
    print("=" * 50)
    
    # Load environment from CSV
    input_file = "environment.csv"
    output_file = "planned_path.csv"
    
    try:
        env = load_environment_from_csv(input_file)
        print(f"Environment loaded from {input_file}")
        print(f"Bounds: {env.width} x {env.height}")
        print(f"Start: ({env.start[0].x}, {env.start[0].y}, {env.start[1]}°)")
        print(f"Goal: ({env.goal[0].x}, {env.goal[0].y}, {env.goal[1]}°)")
        print(f"Obstacles: {len(env.obstacles)}")
        print()
        
        # Run RRT*
        path = rrt_star_dubins(env, n_iter=2000, step_size=5.0, dist_tolerance=2.0)
        
        # Save path to CSV
        save_path_to_csv(path, output_file)
        
    except FileNotFoundError:
        print(f"Error: Could not find {input_file}")
        print("\nExpected CSV format:")
        print("Row 1: width,height,max_curvature")
        print("Row 2: start_x,start_y,start_yaw_deg")
        print("Row 3: goal_x,goal_y,goal_yaw_deg")
        print("Row 4+: obstacle_x1,obstacle_y1,obstacle_x2,obstacle_y2,...")
    except Exception as e:
        print(f"Error: {e}")