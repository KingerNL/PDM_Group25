"""
RRT* Path Planner with Dubins Curves
Inputs: CSV file with environment obstacles
Outputs: CSV file with planned path (x, y, yaw)
"""

import math
import numpy as np
import csv
from scipy.spatial.transform import Rotation as Rot
from shapely.geometry import Point, LineString, Polygon
from tqdm import tqdm

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# ==================== Dubins Path Implementation ====================

class PATH:
    def __init__(self, L, mode, x, y, yaw):
        self.L = L
        self.mode = mode
        self.x = x
        self.y = y
        self.yaw = yaw


def pi_2_pi(theta):
    while theta > math.pi:
        theta -= 2.0 * math.pi
    while theta < -math.pi:
        theta += 2.0 * math.pi
    return theta


def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)


def LSL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)
    
    if p_lsl < 0:
        return None, None, None, ["L", "S", "L"]
    else:
        p_lsl = math.sqrt(p_lsl)
    
    denominate = dist + sin_a - sin_b
    t_lsl = mod2pi(-alpha + math.atan2(cos_b - cos_a, denominate))
    q_lsl = mod2pi(beta - math.atan2(cos_b - cos_a, denominate))
    
    return t_lsl, p_lsl, q_lsl, ["L", "S", "L"]


def RSR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)
    
    if p_rsr < 0:
        return None, None, None, ["R", "S", "R"]
    else:
        p_rsr = math.sqrt(p_rsr)
    
    denominate = dist - sin_a + sin_b
    t_rsr = mod2pi(alpha - math.atan2(cos_a - cos_b, denominate))
    q_rsr = mod2pi(-beta + math.atan2(cos_a - cos_b, denominate))
    
    return t_rsr, p_rsr, q_rsr, ["R", "S", "R"]


def LSR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)
    
    if p_lsr < 0:
        return None, None, None, ["L", "S", "R"]
    else:
        p_lsr = math.sqrt(p_lsr)
    
    rec = math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr)
    t_lsr = mod2pi(-alpha + rec)
    q_lsr = mod2pi(-mod2pi(beta) + rec)
    
    return t_lsr, p_lsr, q_lsr, ["L", "S", "R"]


def RSL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    p_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)
    
    if p_rsl < 0:
        return None, None, None, ["R", "S", "L"]
    else:
        p_rsl = math.sqrt(p_rsl)
    
    rec = math.atan2(cos_a + cos_b, dist - sin_a - sin_b) - math.atan2(2.0, p_rsl)
    t_rsl = mod2pi(alpha - rec)
    q_rsl = mod2pi(beta - rec)
    
    return t_rsl, p_rsl, q_rsl, ["R", "S", "L"]


def RLR(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    rec = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0
    
    if abs(rec) > 1.0:
        return None, None, None, ["R", "L", "R"]
    
    p_rlr = mod2pi(2 * math.pi - math.acos(rec))
    t_rlr = mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + mod2pi(p_rlr / 2.0))
    q_rlr = mod2pi(alpha - beta - t_rlr + mod2pi(p_rlr))
    
    return t_rlr, p_rlr, q_rlr, ["R", "L", "R"]


def LRL(alpha, beta, dist):
    sin_a = math.sin(alpha)
    sin_b = math.sin(beta)
    cos_a = math.cos(alpha)
    cos_b = math.cos(beta)
    cos_a_b = math.cos(alpha - beta)
    
    rec = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_b - sin_a)) / 8.0
    
    if abs(rec) > 1.0:
        return None, None, None, ["L", "R", "L"]
    
    p_lrl = mod2pi(2 * math.pi - math.acos(rec))
    t_lrl = mod2pi(-alpha - math.atan2(cos_a - cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)
    q_lrl = mod2pi(mod2pi(beta) - alpha - t_lrl + mod2pi(p_lrl))
    
    return t_lrl, p_lrl, q_lrl, ["L", "R", "L"]


def interpolate(ind, l, m, maxc, ox, oy, oyaw, px, py, pyaw, directions):
    if m == "S":
        px[ind] = ox + l / maxc * math.cos(oyaw)
        py[ind] = oy + l / maxc * math.sin(oyaw)
        pyaw[ind] = oyaw
    else:
        ldx = math.sin(l) / maxc
        if m == "L":
            ldy = (1.0 - math.cos(l)) / maxc
        elif m == "R":
            ldy = (1.0 - math.cos(l)) / (-maxc)
        
        gdx = math.cos(-oyaw) * ldx + math.sin(-oyaw) * ldy
        gdy = -math.sin(-oyaw) * ldx + math.cos(-oyaw) * ldy
        px[ind] = ox + gdx
        py[ind] = oy + gdy
    
    if m == "L":
        pyaw[ind] = oyaw + l
    elif m == "R":
        pyaw[ind] = oyaw - l
    
    if l > 0.0:
        directions[ind] = 1
    else:
        directions[ind] = -1
    
    return px, py, pyaw, directions


def generate_local_course(L, lengths, mode, maxc, step):
    point_num = int(L / step) + len(lengths) + 3
    
    px = [0.0 for _ in range(point_num)]
    py = [0.0 for _ in range(point_num)]
    pyaw = [0.0 for _ in range(point_num)]
    directions = [0 for _ in range(point_num)]
    ind = 1
    
    if lengths[0] > 0.0:
        directions[0] = 1
    else:
        directions[0] = -1
    
    if lengths[0] > 0.0:
        d = step
    else:
        d = -step
    
    ll = 0.0
    
    for m, l, i in zip(mode, lengths, range(len(mode))):
        if l > 0.0:
            d = step
        else:
            d = -step
        
        ox, oy, oyaw = px[ind], py[ind], pyaw[ind]
        
        ind -= 1
        if i >= 1 and (lengths[i - 1] * lengths[i]) > 0:
            pd = -d - ll
        else:
            pd = d - ll
        
        while abs(pd) <= abs(l):
            ind += 1
            px, py, pyaw, directions = interpolate(ind, pd, m, maxc, ox, oy, oyaw, px, py, pyaw, directions)
            pd += d
        
        ll = l - pd - d
        
        ind += 1
        px, py, pyaw, directions = interpolate(ind, l, m, maxc, ox, oy, oyaw, px, py, pyaw, directions)
    
    if len(px) <= 1:
        return [], [], [], []
    
    while len(px) >= 1 and px[-1] == 0.0:
        px.pop()
        py.pop()
        pyaw.pop()
        directions.pop()
    
    return px, py, pyaw, directions


def planning_from_origin(gx, gy, gyaw, curv, step):
    D = math.hypot(gx, gy)
    d = D * curv
    
    theta = mod2pi(math.atan2(gy, gx))
    alpha = mod2pi(-theta)
    beta = mod2pi(gyaw - theta)
    
    planners = [LSL, RSR, LSR, RSL, RLR, LRL]
    
    path_list = []
    for planner in planners:
        t, p, q, mode = planner(alpha, beta, d)
        
        if t is None:
            continue
        
        cost = (abs(t) + abs(p) + abs(q))
        lengths = [t, p, q]
        x_list, y_list, yaw_list, directions = generate_local_course(sum(lengths), lengths, mode, curv, step)
        path_list.append([x_list, y_list, yaw_list, mode, cost])
    
    return path_list


def calc_dubins_path(sx, sy, syaw, gx, gy, gyaw, curv, step=0.1):
    goal_x = gx - sx
    goal_y = gy - sy
    
    l_rot = Rot.from_euler('z', syaw).as_matrix()[0:2, 0:2]
    le_xy = np.stack([goal_x, goal_y]).T @ l_rot
    le_yaw = gyaw - syaw
    
    possible_paths = []
    path_list = planning_from_origin(le_xy[0], le_xy[1], le_yaw, curv, step)
    for path in path_list:
        lp_x, lp_y, lp_yaw, mode, lengths = path
        rot = Rot.from_euler('z', -syaw).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([lp_x, lp_y]).T @ rot
        x_list = converted_xy[:, 0] + sx
        y_list = converted_xy[:, 1] + sy
        yaw_list = [pi_2_pi(i_yaw + syaw) for i_yaw in lp_yaw]
        possible_paths.append(PATH(lengths, mode, x_list, y_list, yaw_list))
    return possible_paths


def plan_dubins_path(sx, sy, syaw, gx, gy, gyaw, maxc, step=0.2):
    paths = []
    for curve_rate in maxc:
        paths += calc_dubins_path(sx, sy, syaw, gx, gy, gyaw, curve_rate, step)
    if not paths:
        return None
    
    linestring_list = []
    for path in paths:
        x, y = np.array(path.x), np.array(path.y)
        coord = np.vstack((x, y)).T
        linestring_list.append(LineString(coord))
    return sorted(linestring_list, key=lambda x: x.length)


# ==================== RRT* Implementation ====================

class TreeNode:
    def __init__(self, point, yaw):
        self.point = point
        self.yaw = yaw
        self.cost = 0
        self.parent = None
        self.path_to_parent = None
        self.children = []


class Environment:
    def __init__(self, width, height, obstacles, start, goal, max_curvature):
        self.width = width
        self.height = height
        self.obstacles = obstacles
        self.start = start  # (Point, yaw)
        self.goal = goal    # (Point, yaw)
        self.max_curvature = max_curvature
        self.path = None
    
    def collision_free(self, geometry):
        for obstacle in self.obstacles:
            if geometry.intersects(obstacle):
                return False
        return True


def rand_coords(width, height):
    x = np.random.randint(0, width * 100, 1) / 100
    y = np.random.randint(0, height * 100, 1) / 100
    return Point(x, y)


def create_connector(node1, node2, env):
    maxc = env.max_curvature
    sx, sy, syaw = node1.point.x, node1.point.y, round(np.radians(round(node1.yaw, 2)), 2)
    gx, gy, gyaw = node2.point.x, node2.point.y, round(np.radians(round(node2.yaw, 2)), 2)
    
    if gx != sx and gy != sy:
        connect_line_list = plan_dubins_path(sx, sy, syaw, gx, gy, gyaw, maxc)
        if connect_line_list is not None:
            for connect_line in connect_line_list:
                if env.collision_free(connect_line):
                    return connect_line
    return None


def find_closest_node(env, start_node, new_node, min_length=float('inf')):
    nearest_node, shortest_path = None, None
    
    # Use a stack for iterative traversal instead of recursion
    stack = [start_node]
    
    while stack:
        current_node = stack.pop()
        
        # Check connection from current node to new node
        connect_line = create_connector(current_node, new_node, env)
        if connect_line is not None:
            length = connect_line.length
            if length < min_length:
                nearest_node = current_node
                shortest_path = connect_line
                min_length = length
        
        # Add children to stack
        if current_node.children:
            stack.extend(current_node.children)
    
    return nearest_node, shortest_path, min_length


def find_nearby_nodes(start_node, goal_node, tol, nearby_nodes=None):
    if nearby_nodes is None:
        nearby_nodes = []
    
    # Use a stack for iterative traversal
    stack = [start_node]
    
    while stack:
        current_node = stack.pop()
        
        # Check if current node is nearby
        if current_node.point.distance(goal_node.point) < tol:
            nearby_nodes.append(current_node)
        
        # Add children to stack
        if current_node.children:
            stack.extend(current_node.children)
    
    return nearby_nodes


def update_children_cost(start_node, cost_difference):
    # Use a stack for iterative traversal
    stack = [start_node]
    
    while stack:
        current_node = stack.pop()
        
        if current_node.children:
            for child in current_node.children:
                child.cost = child.cost - cost_difference
                stack.append(child)


def extract_path(final_node, path=None):
    if path is None:
        path = []
    
    # Use iteration instead of recursion
    current_node = final_node
    while current_node.parent is not None:
        path.append(current_node.path_to_parent)
        current_node = current_node.parent
    
    return path

def rrt_star_dubins(env, n_iter=1000, step_size=float('inf'), dist_tolerance=1, visualize=True):
    start_node = TreeNode(env.start[0], np.deg2rad(env.start[1]))
    goal_node = TreeNode(env.goal[0], np.deg2rad(env.goal[1]))
    
    valid_nodes_added = 0
    
    # Setup visualization
    if visualize:
        plt.figure(figsize=(10, 10))
        plt.ion()  # Interactive mode on
    
    for n in tqdm(range(n_iter), desc="RRT* Progress"):
        # 20% of the time sample the goal directly
        if np.random.random_sample() < 0.2:
            sampled_node = TreeNode(goal_node.point, goal_node.yaw)
        else:
            sampled_node = TreeNode(rand_coords(env.width, env.height), 
                                  np.deg2rad(np.random.randint(0, 360, 1))[0])
            
            # 50% chance to orient toward goal
            if np.random.random_sample() < 0.5:
                angle_to_goal = (np.degrees(np.arctan2((goal_node.point.y - sampled_node.point.y), 
                                                       (goal_node.point.x - sampled_node.point.x))) + 360) % 360
                sampled_node.yaw = np.deg2rad(angle_to_goal)
        
        if not env.collision_free(sampled_node.point):
            continue
        
        parent_node, path_to_parent, _ = find_closest_node(env, start_node, sampled_node)
        
        if parent_node is not None and not parent_node.point.equals(sampled_node.point):
            if path_to_parent.length > step_size:
                new_node_inradius = TreeNode(path_to_parent.interpolate(step_size), parent_node.yaw)
                sampled_node = new_node_inradius
            
            sampled_node.cost = parent_node.cost + path_to_parent.length
            radius = 0.5
            #radius = min(50, 30 * ((math.log(valid_nodes_added + 1) / (valid_nodes_added + 1)) ** (1/2)))
            nodes_near_sample = find_nearby_nodes(start_node, sampled_node, radius)
            
            if nodes_near_sample:
                min_cost = sampled_node.cost
                
                for node in nodes_near_sample:
                    cost_estimate = sampled_node.point.distance(node.point) + min(abs(sampled_node.yaw - node.yaw), 
                                                                                   2 * math.pi - abs(sampled_node.yaw - node.yaw))
                    cost_via_node = node.cost + cost_estimate
                    
                    if cost_via_node < min_cost:
                        parent_node, min_cost = node, cost_via_node
            
            path_to_parent = create_connector(parent_node, sampled_node, env)
            if path_to_parent is None:
                continue
            
            sampled_node.cost = parent_node.cost + path_to_parent.length
            parent_node.children.append(sampled_node)
            sampled_node.parent = parent_node
            sampled_node.path_to_parent = path_to_parent
            valid_nodes_added += 1
            
            # Visualize every 50 iterations
            if visualize and n % 50 == 0:
                visualize_rrt_progress(env, start_node, goal_node, n, sampled_node, path_to_parent)
            
            if nodes_near_sample:
                for node in nodes_near_sample:
                    cost_estimate = sampled_node.point.distance(node.point) + min(abs(sampled_node.yaw - node.yaw), 
                                                                                   2 * math.pi - abs(sampled_node.yaw - node.yaw))
                    cost_via_sampled_node = sampled_node.cost + cost_estimate
                    
                    if cost_via_sampled_node < node.cost:
                        path_to_node = create_connector(sampled_node, node, env)
                        if path_to_node is None:
                            continue
                        
                        node_updated_cost = sampled_node.cost + path_to_node.length
                        if node_updated_cost < node.cost:
                            node.parent.children.remove(node)
                            node.parent = sampled_node
                            node.path_to_parent = path_to_node
                            sampled_node.children.append(node)
                            
                            node_cost_difference = node.cost - node_updated_cost
                            update_children_cost(node, node_cost_difference)
        
        if n % 200 == 0 and n > 0:
            print(f"\nIteration {n}: Added {valid_nodes_added} valid nodes to tree")
    
    # Final visualization
    if visualize:
        visualize_rrt_progress(env, start_node, goal_node, n_iter)
        plt.ioff()
    
    print(f"\nTotal valid nodes added: {valid_nodes_added}")
    
    # ... rest of your code for finding path ...
    
    

def visualize_rrt_progress(env, start_node, goal_node, iteration, sampled_node=None, new_connection=None):
    """
    Visualize the RRT* tree growth in real-time
    """
    plt.cla()
    
    # Set plot limits
    plt.xlim([0, env.width])
    plt.ylim([0, env.height])
    plt.axis("equal")
    
    # Draw obstacles
    for obstacle in env.obstacles:
        if obstacle.geom_type == 'Polygon':
            plt.gca().add_patch(patches.Polygon(list(obstacle.exterior.coords), 
                                               color="grey", alpha=0.7))
    
    # Draw start and goal
    plt.plot(env.start[0].x, env.start[0].y, 'go', markersize=12, label='Start')
    plt.plot(env.goal[0].x, env.goal[0].y, 'r*', markersize=15, label='Goal')
    
    # Draw goal tolerance circle
    goal_circle = plt.Circle((env.goal[0].x, env.goal[0].y), 
                             20.0,  # Use your dist_tolerance value
                             color='red', fill=False, linestyle='--', alpha=0.3)
    plt.gca().add_patch(goal_circle)
    
    # Draw tree - traverse and plot all connections
    def draw_tree(node):
        if node.children:
            for child in node.children:
                if child.path_to_parent is not None:
                    coords = list(child.path_to_parent.coords)
                    xs, ys = zip(*coords)
                    plt.plot(xs, ys, 'b-', linewidth=0.5, alpha=0.6)
                draw_tree(child)
    
    draw_tree(start_node)
    
    # Highlight the new connection if provided
    if new_connection is not None:
        coords = list(new_connection.coords)
        xs, ys = zip(*coords)
        plt.plot(xs, ys, 'g-', linewidth=2, alpha=0.8)
    
    # Draw sampled node
    if sampled_node is not None:
        plt.plot(sampled_node.point.x, sampled_node.point.y, 'ro', markersize=4)
    
    plt.title(f'RRT* Progress - Iteration {iteration}')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.pause(0.001)
    
    # Allow ESC key to exit
    plt.gcf().canvas.mpl_connect('key_release_event',
                                lambda event: exit(0) if event.key == 'escape' else None)

# ==================== CSV I/O Functions ====================

def load_environment_from_csv(filename):
    """
    Load environment from CSV file.
    Expected format:
    - First row: width,height,max_curvature
    - Second row: start_x,start_y,start_yaw_deg
    - Third row: goal_x,goal_y,goal_yaw_deg
    - Following rows: obstacle vertices as x1,y1,x2,y2,x3,y3,...
    """
    with open(filename, 'r') as f:
        reader = csv.reader(f)
        rows = list(reader)  # Convert to list
        print(rows)
        # Read environment dimensions and parameters (row 0)
        width, height, max_curv = float(rows[1][0]), float(rows[1][1]), [float(rows[1][2])]
        
        # Read start position (row 1)
        start = (Point(float(rows[2][0]), float(rows[2][1])), float(rows[2][2]))
        
        # Read goal position (row 2)
        goal = (Point(float(rows[3][0]), float(rows[3][1])), float(rows[3][2]))
        
        # Read obstacles (row 3 onwards)
        obstacles = []
        for i in range(4, len(rows)):
            row = rows[i]
            if row and len(row) >= 6:  # At least 3 points (x,y pairs) to make a polygon
                coords = [(float(row[j]), float(row[j+1])) for j in range(0, len(row), 2)]
                obstacles.append(Polygon(coords))
        
    return Environment(width, height, obstacles, start, goal, max_curv)

def save_path_to_csv(path, filename):
    """
    Save path to CSV file with x, y, yaw columns.
    """
    with open(filename, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['x', 'y', 'yaw_deg'])
        
        for segment in path:
            coords = list(segment.coords)
            for coord in coords:
                x, y = coord
                # Extract yaw from segment (simplified - using direction between points)
                idx = coords.index(coord)
                if idx < len(coords) - 1:
                    dx = coords[idx + 1][0] - x
                    dy = coords[idx + 1][1] - y
                    yaw_rad = math.atan2(dy, dx)
                    yaw_deg = math.degrees(yaw_rad)
                else:
                    yaw_deg = math.degrees(yaw_rad) if idx > 0 else 0
                
                writer.writerow([x, y, yaw_deg])
    
    print(f"Path saved to {filename}")


# ==================== Main Function ====================

if __name__ == "__main__":
    # Example usage
    print("RRT* with Dubins Path Planner")
    print("=" * 50)
    
    # Load environment from CSV
    input_file = "/home/jipr/Robotics_master/PDM/project/PDM_Group25/RRTs/environment.csv"
    output_file = "planned_path.csv"
    
    try:
        env = load_environment_from_csv(input_file)
        print(f"Environment loaded from {input_file}")
        print(f"Bounds: {env.width} x {env.height}")
        print(f"Start: ({env.start[0].x}, {env.start[0].y}, {env.start[1]}°)")
        print(f"Goal: ({env.goal[0].x}, {env.goal[0].y}, {env.goal[1]}°)")
        print(f"Obstacles: {len(env.obstacles)}")
        print()
        
        # Run RRT*
        path = rrt_star_dubins(env, n_iter=1000, step_size=1.0, dist_tolerance=10.0, visualize=True)      
        # Save path to CSV
        save_path_to_csv(path, output_file)
        
    except FileNotFoundError:
        print(f"Error: Could not find {input_file}")
        print("\nExpected CSV format:")
        print("Row 1: width,height,max_curvature")
        print("Row 2: start_x,start_y,start_yaw_deg")
        print("Row 3: goal_x,goal_y,goal_yaw_deg")
        print("Row 4+: obstacle_x1,obstacle_y1,obstacle_x2,obstacle_y2,...")
    except Exception as e:
        print(f"Error: {e}")